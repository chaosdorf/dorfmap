#!/usr/bin/env perl

use strict;
use warnings;
use 5.010;

use App::Daemon qw(daemonize);
use DateTime;
use File::Slurp qw(read_file write_file);
use LWP::UserAgent;

$App::Daemon::as_user = 'www-data';
$App::Daemon::logfile = '/tmp/dorfmap-bgdata.log';

daemonize();

our $VERSION = '0.01';

my $ua = LWP::UserAgent->new;
$ua->timeout(2);

my $re_host = qr{
	^
	(?<host> \S+ )
}x;

my $re_pingdev = qr{
	^
	(?<host> \S+ )
	.* type = (?: phone | printer | server | wifi )
}x;

my $re_pingdev_section = qr{
	^
	\[
	.* type = (?: phone | printer | server | wifi )
}x;

my $re_other_section = qr{
	^
	\[
}x;

my $re_autooff = qr{
	^
	(?: \S+ ) \s+ # device
	(?: \S+ ) \s+ # x
	(?: \S+ ) \s+ # y
	(?: \S+ ) \s+ # w
	(?: \S+ ) \s+ # h
	(?<path> \S+)
	.* autooff = (?<duration> \d+) (?<unit> [dhms])
}x;

my %units = (
	s => 1,
	m => 60,
	h => 60 * 60,
	d => 60 * 60 * 24,
);

sub slurp {
	my ($file) = @_;

	my $content = read_file( $file, err_mode => 'quiet' );
	if ( defined $content ) {
		chomp $content;
	}
	return $content;
}

sub spew {
	my ( $file, $value ) = @_;

	return write_file( $file, { err_mode => 'quiet' }, $value );
}

sub ping_host {
	my ($host) = @_;

	system( qw( ping -n -c 1 -W 1 ), $host );

	write_file( "/srv/www/${host}.ping", ( $? == 0 ) ? '1' : '0' );

	return;
}

while ( sleep(120) ) {

	my %autooff;

	my $raw_coordinates = read_file('coordinates');
	$raw_coordinates =~ s{\\\n}{}gs;
	my $in_pingdev_section = 0;

	for my $line ( split( /\n/, $raw_coordinates ) ) {
		if ( $line =~ $re_pingdev_section ) {
			$in_pingdev_section = 1;
		}
		elsif ( $line =~ $re_other_section ) {
			$in_pingdev_section = 0;
		}
		elsif ( $line =~ $re_pingdev ) {
			ping_host( $+{host} );
		}
		elsif ( $in_pingdev_section and $line =~ $re_host ) {
			ping_host( $+{host} );
		}

		if ( $line =~ $re_autooff ) {
			my $device = '/tmp/' . $+{path};
			my $delay  = $+{duration} * $units{ $+{unit} };

			if ( -e $device and slurp($device) == 1 ) {
				my $now = DateTime->now( time_zone => 'Europe/Berlin' )->epoch;
				my $modified = ( stat($device) )[9];
				if ( ( $now - $modified ) > $delay ) {
					spew( $device, "0\n" );
					system( 'dorfmap_set_remote',
						( split( /\//, $device ) )[0] );
				}
			}
		}
	}

	my $res = $ua->get('http://door/status');
	if ( $res->is_success ) {
		write_file( '/srv/www/doorstatus', $res->decoded_content );
	}
	else {
		write_file( '/srv/www/doorstatus', -1 );
	}

}

__END__

=head1 NAME

=head1 SYNOPSIS

=head1 VERSION

=head1 DESCRIPTION

=head1 OPTIONS

=over

=back

=head1 EXIT STATUS

=head1 CONFIGURATION

None.

=head1 DEPENDENCIES

=over

=back

=head1 BUGS AND LIMITATIONS

=head1 AUTHOR

Copyright (C) 2013 by Daniel Friesel E<lt>derf@finalrewind.orgE<gt>

=head1 LICENSE

  0. You just DO WHAT THE FUCK YOU WANT TO.
