#!/usr/bin/env perl

use strict;
use warnings;
use 5.010;

use App::Daemon qw(daemonize);
use DateTime;
use File::Slurp qw(read_file write_file);
use JSON;
use List::Util qw(sum);
use LWP::UserAgent;

$App::Daemon::as_user = 'www-data';
$App::Daemon::logfile = '/tmp/fluksod.log';

daemonize();

our $VERSION = '0.02';

my $out_prefix = '/srv/www/flukso';
my %cache;
my @intervals = qw(30 60 300 600 3600);

# current timestamp is latest one returned from flukso to avoid clock desync
my $now;

my $re_pair = qr{
	\[ (?<timestamp> \d+ ) , (?<value> \d+ ) \]
}x;

my $ua = LWP::UserAgent->new;
$ua->timeout(4);

sub slurp {
	my ($file) = @_;

	my $content = read_file( $file, err_mode => 'quiet' );
	if ( defined $content ) {
		chomp $content;
	}
	return $content;
}

sub spew {
	my ( $file, $value ) = @_;

	return write_file( $file, { err_mode => 'quiet' }, $value );
}

for my $interval (@intervals) {
	for my $phase (qw(p1 p2 p3)) {
		@{ $cache{$phase}{$interval} } = (0) x $interval;
	}
}

mkdir($out_prefix);

while ( sleep(7) ) {

	my %sums;

	my $request_errors = 0;

	for my $pair (
		[ 'p1', 'd80587d41bebde066f003a8f60ac0d01' ],
		[ 'p2', '2267a0503927a5f2bbf0050f657dcc55' ],
		[ 'p3', '90d083c153310b5787e3f1a7fc7967a5' ]
	  )
	{

		my ( $name, $id ) = @{$pair};

		# host lookups take a while on the raspi (~800ms additional user time)
		# -> use raw IP
		my $res
		  = $ua->get(
"http://192.168.0.18:8080/sensor/${id}?version=1.0&interval=minute&unit=watt&callback=realtime"
		  );

		if ( not $res->is_success ) {
			for my $interval (@intervals) {
				spew( "${out_prefix}/${interval}_${name}", -1 );
			}
			$request_errors++;
			next;
		}

		my $content = $res->decoded_content;

		while ( $content =~ s{$re_pair}{} ) {
			my ( $ts, $value ) = @+{ 'timestamp', 'value' };

			for my $interval (@intervals) {
				$cache{$name}{$interval}[ $ts % $interval ] = $value;
			}
		}
		for my $interval (@intervals) {
			my $avg = ( sum @{ $cache{$name}{$interval} } ) / $interval;
			spew( "${out_prefix}/${interval}_${name}", $avg );
			$sums{$interval} += $avg;
		}
	}
	for my $interval (@intervals) {
		if ( $request_errors < 3 ) {
			spew( "${out_prefix}/${interval}", $sums{$interval} );
		}
		else {
			spew( "${out_prefix}/${interval}", -1 );
		}
	}
}
