#!/usr/bin/env perl

use strict;
use warnings;
use 5.010;

use App::Daemon qw(daemonize);
use DateTime;
use File::Slurp qw(read_file write_file);
use JSON;
use List::Util qw(sum);
use LWP::UserAgent;

$App::Daemon::as_user = 'www-data';
$App::Daemon::logfile = '/tmp/fluksod.log';

daemonize();

our $VERSION = '0.02';

my $out_prefix = '/srv/www/flukso';
my %cache;

# current timestamp is latest one returned from flukso to avoid clock desync
my $now;

my $re_pair = qr{
	\[ (?<timestamp> \d+ ) , (?<value> \d+ ) \]
}x;

my $ua = LWP::UserAgent->new;
$ua->timeout(4);

sub slurp {
	my ($file) = @_;

	my $content = read_file( $file, err_mode => 'quiet' );
	if ( defined $content ) {
		chomp $content;
	}
	return $content;
}

sub spew {
	my ( $file, $value ) = @_;

	return write_file( $file, { err_mode => 'quiet' }, $value );
}

mkdir($out_prefix);

while ( sleep(7) ) {

	for my $pair (
		[ 'p1', 'd80587d41bebde066f003a8f60ac0d01' ],
		[ 'p2', '2267a0503927a5f2bbf0050f657dcc55' ],
		[ 'p3', '90d083c153310b5787e3f1a7fc7967a5' ]
	  )
	{

		my ( $name, $id ) = @{$pair};

		# host lookups take a while on the raspi (~800ms additional user time)
		# -> use raw IP
		my $res
		  = $ua->get(
"http://172.22.26.11:8080/sensor/${id}?version=1.0&interval=minute&unit=watt&callback=realtime"
		  );

		if ( not $res->is_success ) {
			next;
		}

		my $content = $res->decoded_content;

		while ( $content =~ s{$re_pair}{} ) {
			my ( $ts, $value ) = @+{ 'timestamp', 'value' };

			if ( not exists $cache{$ts}{$name} ) {
				$cache{$ts}{$name} = $value;
				$cache{$ts}{total} += $value;
				$now = $ts;
			}
		}
	}

	for my $ts ( ( $now - 7220 ) .. ( $now - 7200 ) ) {
		delete $cache{$ts};
	}

	my ( %phase_sum, %phase_cnt );
	for my $offset ( 0 .. 3600 ) {
		my $ts = $now - $offset;
		for my $phase (qw(p1 p2 p3)) {
			if ( exists $cache{$ts}{$phase} ) {
				$phase_sum{$phase} += $cache{$ts}{$phase};
				$phase_cnt{$phase}++;
			}
		}
		if ( $offset ~~ [qw[30 60 300 600 3600]] ) {
			my %phase_avg;
			for my $phase (qw(p1 p2 p3)) {
				if ( $phase_cnt{$phase} ) {
					$phase_avg{$phase}
					  = $phase_sum{$phase} / $phase_cnt{$phase};
				}
				else {
					$phase_avg{$phase} = -1;
				}
				spew( "${out_prefix}/${offset}_${phase}", $phase_avg{$phase} );
			}
			spew( "${out_prefix}/${offset}", sum values %phase_avg );
		}
	}

	my $history = q{};
	for my $ts ( sort keys %cache ) {
		$history .= sprintf(
			"%d,%4d,%4d,%4d\n",
			$ts,
			$cache{$ts}{p1} // -1,
			$cache{$ts}{p2} // -1,
			$cache{$ts}{p3} // -1
		);
	}
	spew( "${out_prefix}/dump", $history );

}
